<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BSMI K-Line Viewer</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    html, body { height: 100%; }
    body { font-family: "Times New Roman", serif; margin: 0; padding: 0; background: #000; color: #e0e0e0; display: flex; flex-direction: column; position: relative; }
    #controls { padding: 10px; border-bottom: 1px solid #444; background: #111; flex: 0 0 auto; }
    .section { margin-bottom: 8px; }
    #chart { width: 100%; flex: 1 1 auto; min-height: 0; }
    label { margin-right: 10px; }
    .color-dot { display:inline-block; width:12px; height:12px; border-radius:2px; margin-left:4px; vertical-align:middle; }
    #hoverbar {
      position: absolute;
      left: 10px;
      right: 10px;
      top: 60px;
      padding: 4px 0;
      color: #ff4444;
      font-size: 16px;
      background: transparent;
      visibility: hidden;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
      line-height: 20px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="section">
      <label>BSMI Month:</label>
      <select id="monthSelect"></select>
      <span id="status"></span>
    </div>
    <div class="section">
      <div>
        <strong>Time averages:</strong>
        <label><input type="checkbox" class="toggle" data-trace="ma10" checked> MA_10min</label>
        <label><input type="checkbox" class="toggle" data-trace="ma1h"> MA_1h</label>
        <label><input type="checkbox" class="toggle" data-trace="ma6h"> MA_6h</label>
        <label><input type="checkbox" class="toggle" data-trace="ma1mo"> MA_1mo</label>
      </div>
      <div style="margin-top:6px;">
        <strong>Series:</strong>
        <label><input type="checkbox" class="toggle" data-trace="ws100" checked> <span class="color-dot" style="background:#1f77b4"></span> WS_100</label>
        <label><input type="checkbox" class="toggle" data-trace="ws69"> <span class="color-dot" style="background:#00c1b2"></span> WS_69W</label>
        <label><input type="checkbox" class="toggle" data-trace="ws38"> <span class="color-dot" style="background:#f5d300"></span> WS_38W</label>
        <label><input type="checkbox" class="toggle" data-trace="wd97" checked> <span class="color-dot" style="background:#ff8c00"></span> WD_97</label>
        <label><input type="checkbox" class="toggle" data-trace="wd35"> <span class="color-dot" style="background:#f5c49e"></span> WD_35</label>
        <label><input type="checkbox" class="toggle" data-trace="at"> <span class="color-dot" style="background:#bcbd22"></span> AT_95</label>
        <label><input type="checkbox" class="toggle" data-trace="rh"> <span class="color-dot" style="background:#d62728"></span> RH_95</label>
        <label><input type="checkbox" class="toggle" data-trace="bp"> <span class="color-dot" style="background:#9b59b6"></span> BP_93</label>
        <label><input type="checkbox" class="toggle" data-trace="ti"> <span class="color-dot" style="background:#e377c2"></span> TI_10min</label>
        <label><input type="checkbox" class="toggle" data-trace="gust"> <span class="color-dot" style="background:#7f7f7f"></span> GustFactor</label>
      </div>
    </div>
  </div>
  <div id="hoverbar"></div>
  <div id="chart"></div>

  <script>
    const fallbackMonths = ["201603","201604","201605","201606","201607","201608","201609","201610","201611","201612","201701","201702","201703","201704","201705","201706","201707","201708","201709","201710","201711","201712","201801","201802","201803","201804","201805","201806","201807","201808","201809","201810","201811","201812","201901","201902","201903","201904","201905","201906","201907","201908","201909","201910","201911","201912","202001","202002","202003","202004","202005","202006","202007","202008","202009","202010","202011","202012","202101","202102","202103","202104","202105","202106","202107","202108","202109","202110","202111","202112","202201","202202","202203","202204","202205","202206","202207","202208","202209","202210","202211","202301","202302","202303","202304","202305","202306","202307","202308","202309","202310","202311","202312","202401","202402","202403","202404","202405","202406","202407","202408","202409","202410","202411","202412","202501","202502","202503"];
    let months = [...fallbackMonths]; // fallback
    const cache = {};
    const aggBase = "../DATA/bsmikline/agg";

    const axisColors = {
      ws: "#1f77b4",
      ma10: "#2ca02c",
      ma1h: "#ff7f0e",
      ma6h: "#9467bd",
      ma1m: "#17becf",
      rh: "#d62728",
      bp: "#9b59b6",
      wd: "#ff8c00",
      wd35: "#f5c49e",
      wdGrey: "#7f7f7f",
      ws69: "#00c1b2",
      ws38: "#f5d300",
      at: "#bcbd22",
      ti: "#e377c2",
      gust: "#7f7f7f"
    };
    const maConfigs = [
      {chk:"ma10", label:"MA_10min", minutes:10, shade:1.0},
      {chk:"ma1h", label:"MA_1h", minutes:60, shade:0.8},
      {chk:"ma6h", label:"MA_6h", minutes:360, shade:0.6},
      {chk:"ma1mo", label:"MA_1mo", minutes:30*24*60, shade:0.4},
    ];

    async function buildMonthOptions() {
      const sel = document.getElementById("monthSelect");
      sel.innerHTML = "";
      months.forEach(m => {
        const opt = document.createElement("option");
        opt.value = m;
        opt.textContent = m;
        sel.appendChild(opt);
      });
      sel.value = months[0];
    }

    function setStatus(msg) {
      document.getElementById("status").textContent = msg;
    }

    async function loadMonth(month) {
      if (cache[month]) return cache[month];
      setStatus("Loading " + month + "...");
      const url = `${aggBase}/BSMI${month}.csv`;
      const resp = await fetch(url);
      if (!resp.ok) {
        throw new Error("Failed to load " + url);
      }
      const text = await resp.text();
      const rows = text.trim().split(/\r?\n/);
      const header = rows.shift().split(",");
      const data = header.reduce((acc, h) => { acc[h] = []; return acc; }, {});
      rows.forEach(line => {
        const cols = line.split(",");
        header.forEach((h, i) => data[h].push(cols[i] === "" ? null : (h === "TIMESTAMP" ? new Date(cols[i]) : parseFloat(cols[i]))));
      });
      cache[month] = data;
      setStatus("");
      return data;
    }

    function breakDirection(dir) {
      const out = [];
      for (let i = 0; i < dir.length; i++) {
        if (i === 0) { out.push(dir[i]); continue; }
        const prev = dir[i-1], cur = dir[i];
        if (prev == null || cur == null) { out.push(null); continue; }
        const diff = Math.abs(cur - prev);
        if (diff > 180) out.push(null);
        out.push(cur);
      }
      return out;
    }

    function statsFor(series) {
      const vals = series.filter(v => v !== null && !Number.isNaN(v));
      if (!vals.length) return null;
      vals.sort((a,b) => a-b);
      const q = p => {
        const idx = (vals.length - 1) * p;
        const lo = Math.floor(idx), hi = Math.ceil(idx);
        if (lo === hi) return vals[lo];
        return vals[lo] * (hi - idx) + vals[hi] * (idx - lo);
      };
      return {min: vals[0], q1: q(0.25), med: q(0.5), q3: q(0.75), max: vals[vals.length-1]};
    }

    function attachStats(series, stats) {
      if (!stats) return null;
      return Array(series.length).fill([stats.min, stats.q1, stats.med, stats.q3, stats.max]);
    }

    function isChecked(key) {
      const el = document.querySelector(`.toggle[data-trace='${key}']`);
      return el ? el.checked : false;
    }

    function getActiveWindowMinutes() {
      const order = [
        {chk:"ma10", minutes:10},
        {chk:"ma1h", minutes:60},
        {chk:"ma6h", minutes:360},
        {chk:"ma1mo", minutes:30*24*60},
      ];
      for (const item of order) {
        const el = document.querySelector(`.toggle[data-trace='${item.chk}']`);
        if (el && el.checked) return item.minutes;
      }
      return 10;
    }

    function quantiles(arr) {
      if (!arr.length) return [null,null,null,null,null];
      const sorted = [...arr].sort((a,b)=>a-b);
      const q = p => {
        const idx = (sorted.length - 1) * p;
        const lo = Math.floor(idx), hi = Math.ceil(idx);
        if (lo === hi) return sorted[lo];
        return sorted[lo]*(hi-idx)+sorted[hi]*(idx-lo);
      };
      return [sorted[0], q(0.25), q(0.5), q(0.75), sorted[sorted.length-1]];
    }

    function rollingStats(series, times, windowMin) {
      const res = {min:[], q1:[], med:[], q3:[], max:[]};
      if (!series || !series.length) return res;
      const stepMin = times.length>1 ? (times[1]-times[0])/(1000*60) : 1;
      let winCount = Math.max(1, Math.round(windowMin / Math.max(stepMin,1)));
      if (winCount > 1000) winCount = 1000; // avoid heavy windows
      for (let i=0;i<series.length;i++){
        const start = Math.max(0, i - winCount + 1);
        const slice = [];
        for (let j=start;j<=i;j++){
          const v = series[j];
          if (v!==null && !Number.isNaN(v)) slice.push(v);
        }
        const [mn,q1,med,q3,mx] = quantiles(slice);
        res.min.push(mn); res.q1.push(q1); res.med.push(med); res.q3.push(q3); res.max.push(mx);
      }
      return res;
    }

    function computeMA(series, times, windowMin) {
      if (!series || !series.length) return [];
      const stepMin = times.length>1 ? (times[1]-times[0])/(1000*60) : 1;
      let winCount = Math.max(1, Math.round(windowMin / Math.max(stepMin,1)));
      if (winCount < 1) winCount = 1;
      const res = [];
      const queue = [];
      let sum = 0;
      let count = 0;
      for (let i=0;i<series.length;i++){
        const v = series[i];
        queue.push(v);
        if (v!==null && !Number.isNaN(v)) { sum += v; count += 1; }
        if (queue.length > winCount) {
          const old = queue.shift();
          if (old!==null && !Number.isNaN(old)) { sum -= old; count -= 1; }
        }
        res.push(count>0 ? sum/count : null);
      }
      return res;
    }

    function shadeColor(hex, factor) {
      const h = hex.replace("#","").padEnd(6,"0");
      const r = Math.round(parseInt(h.substring(0,2),16) * factor);
      const g = Math.round(parseInt(h.substring(2,4),16) * factor);
      const b = Math.round(parseInt(h.substring(4,6),16) * factor);
      const clamp = v => Math.min(255, Math.max(0, v));
      return "#" + clamp(r).toString(16).padStart(2,"0") + clamp(g).toString(16).padStart(2,"0") + clamp(b).toString(16).padStart(2,"0");
    }

    function buildCustomData(series, stats, maArr) {
      const out = [];
      for (let i=0;i<series.length;i++){
        const val = (maArr && maArr[i]!==undefined) ? maArr[i] : series[i];
        out.push([val, stats.min[i], stats.q1[i], stats.med[i], stats.q3[i], stats.max[i]]);
      }
      return out;
    }

    function makeTraces(d) {
      const t = d["TIMESTAMP"];
      const traces = [];
      const hoverNone = {hovertemplate:"", hoverinfo:"none", hoverlabel:{bgcolor:"rgba(0,0,0,0)", bordercolor:"rgba(0,0,0,0)", font:{color:"rgba(0,0,0,0)"}}};
      const seriesList = [
        {chk:"ws100", key:"WS_100", baseColor:axisColors.ws, axis:"y"},
        {chk:"ws69", key:"WS_69W", baseColor:axisColors.ws69, axis:"y"},
        {chk:"ws38", key:"WS_38W", baseColor:axisColors.ws38, axis:"y"},
        {chk:"wd97", key:"WD_97", baseColor:axisColors.wd, axis:"y4", transform:breakDirection},
        {chk:"wd35", key:"WD_35", baseColor:axisColors.wd35, axis:"y4", transform:breakDirection},
        {chk:"at", key:"AT_95", baseColor:axisColors.at, axis:"y5"},
        {chk:"rh", key:"RH_95", baseColor:axisColors.rh, axis:"y2"},
        {chk:"bp", key:"BP_93", baseColor:axisColors.bp, axis:"y3"},
        {chk:"ti", key:"TI_10min", baseColor:axisColors.ti, axis:"y6"},
        {chk:"gust", key:"GustFactor", baseColor:axisColors.gust, axis:"y6", mode:"markers", marker:{color:axisColors.gust, size:3}},
      ];

      const selectedMas = maConfigs.filter(cfg => isChecked(cfg.chk));
      const selectedSeries = seriesList.filter(s => isChecked(s.chk));
      const maCache = {};

      selectedMas.forEach(cfg => {
        selectedSeries.forEach(s => {
          const base = d[s.key];
          if (!base) return;
          let yArr;
          if (cfg.minutes === 10) {
            yArr = s.transform ? s.transform(base) : base;
          } else {
            if (!maCache[cfg.minutes]) maCache[cfg.minutes] = {};
            if (!maCache[cfg.minutes][s.key]) {
              const raw = s.transform ? s.transform(base) : base;
              maCache[cfg.minutes][s.key] = computeMA(raw, t, cfg.minutes);
            }
            yArr = maCache[cfg.minutes][s.key];
          }
          const color = cfg.minutes === 10 ? s.baseColor : shadeColor(s.baseColor, cfg.shade);
          const isMarkers = s.mode === "markers";
          traces.push({
            type: "scattergl",
            mode: s.mode || "lines",
            name: s.key,
            meta: {series: s.key, ma: cfg.label},
            x: t,
            y: yArr,
            yaxis: s.axis,
            line: isMarkers ? undefined : {color, width:1},
            marker: isMarkers ? (s.marker ? {...s.marker, color} : {color}) : {color:"rgba(0,0,0,0)"},
            visible: true,
            ...hoverNone
          });
        });
      });

      return traces;
    }

    function layoutTemplate() {
      return {
        font: {family:"Times New Roman, serif", color:"#e0e0e0"},
        paper_bgcolor:"#000",
        plot_bgcolor:"#000",
        hovermode:"x unified",
        hoverlabel:{bgcolor:"rgba(0,0,0,0)", bordercolor:"rgba(0,0,0,0)", font:{color:"rgba(0,0,0,0)"}},
        xaxis: {
          title: "Time",
          showspikes:true,
          spikemode:"across",
          spikecolor:"#ffffff",
          spikethickness:1,
          spikedash:"dash",
          spikesnap:"cursor",
          rangeslider:{visible:false},
          gridcolor:"#222",
          zerolinecolor:"#333",
        },
        yaxis: {title: "Wind speed (m/s)", domain:[0.05,0.98], gridcolor:"#222", zerolinecolor:"#333", showspikes:true, spikemode:"across", spikedash:"dash", spikecolor:"#ffffff", spikethickness:1, spikesnap:"cursor"},
        yaxis2: {title: "", overlaying:"y", side:"right", position:1.02, anchor:"free", showgrid:false, tickfont:{color:axisColors.rh}, titlefont:{color:axisColors.rh}, showline:false, showspikes:true, spikemode:"across", spikedash:"dash", spikecolor:"#ffffff", spikethickness:1, spikesnap:"cursor"},
        yaxis3: {title: "", overlaying:"y", side:"right", position:1.08, anchor:"free", showgrid:false, tickfont:{color:axisColors.bp}, titlefont:{color:axisColors.bp}, showline:false, showspikes:true, spikemode:"across", spikedash:"dash", spikecolor:"#ffffff", spikethickness:1, spikesnap:"cursor"},
        yaxis4: {title: "", overlaying:"y", side:"right", position:1.14, anchor:"free", range:[0,360], showgrid:false, tickfont:{color:axisColors.wd}, titlefont:{color:axisColors.wd}, showline:false, showspikes:true, spikemode:"across", spikedash:"dash", spikecolor:"#ffffff", spikethickness:1, spikesnap:"cursor"},
        yaxis5: {title: "", overlaying:"y", side:"right", position:1.20, anchor:"free", showgrid:false, tickfont:{color:axisColors.at}, titlefont:{color:axisColors.at}, showline:false, showspikes:true, spikemode:"across", spikedash:"dash", spikecolor:"#ffffff", spikethickness:1, spikesnap:"cursor"},
        yaxis6: {overlaying:"y", side:"right", position:1.26, anchor:"free", showgrid:false, showticklabels:false, zeroline:false, title:"", showspikes:true, spikemode:"across", spikedash:"dash", spikecolor:"#ffffff", spikethickness:1, spikesnap:"cursor"},
        showlegend: false,
        margin: {l:60, r:220, t:30, b:30},
      };
    }

    async function render(month) {
      try {
        const data = await loadMonth(month);
        const n = (data["WS_100"] || []).filter(v => v !== null && !Number.isNaN(v)).length;
        const traces = makeTraces(data);
        await Plotly.newPlot("chart", traces, layoutTemplate(), {responsive:true, displaylogo:false});
        bindHoverbar();
        setStatus(`Loaded ${month} (${n} points)`);
        bindToggles(traces);
      } catch (err) {
        console.error(err);
        setStatus("Error: " + err.message);
      }
    }

    function bindToggles(traces) {
      const nameToIdx = {};
      traces.forEach((tr, i) => {
        const key = (tr.meta && tr.meta.series) ? tr.meta.series : tr.name;
        if (!nameToIdx[key]) nameToIdx[key] = [];
        nameToIdx[key].push(i);
      });
      const mapping = {
        ws100: ["WS_100"],
        ws69: ["WS_69W"],
        ws38: ["WS_38W"],
        wd97: ["WD_97"],
        wd35: ["WD_35"],
        at: ["AT_95"],
        rh: ["RH_95"],
        bp: ["BP_93"],
        ti: ["TI_10min"],
        gust: ["GustFactor"],
      };
      document.querySelectorAll('.toggle').forEach(cb => {
        cb.onchange = () => {
          if (["ma10","ma1h","ma6h","ma1mo"].includes(cb.dataset.trace)) {
            const current = document.getElementById("monthSelect").value;
            render(current);
            return;
          }
          const names = mapping[cb.dataset.trace] || [];
          const visibility = cb.checked ? true : "legendonly";
          names.forEach(name => {
            (nameToIdx[name] || []).forEach(i => Plotly.restyle("chart", {visible: visibility}, i));
          });
        };
      });
    }

    function bindHoverbar() {
      const gd = document.getElementById("chart");
      const hb = document.getElementById("hoverbar");
      const adjustPos = () => {
        const ctrl = document.getElementById("controls");
        const top = ctrl ? ctrl.offsetHeight + 4 : 60;
        hb.style.top = `${top}px`;
      };
      adjustPos();
      window.addEventListener("resize", adjustPos);
      gd.on('plotly_hover', (data) => {
        if (!data || !data.points || !data.points.length) { hb.style.visibility = 'hidden'; hb.textContent=''; return; }
        const pts = data.points;
        const t = pts[0].x;
        const ts = (t instanceof Date) ? `${t.getFullYear()}-${String(t.getMonth()+1).padStart(2,'0')}-${String(t.getDate()).padStart(2,'0')} ${String(t.getHours()).padStart(2,'0')}:${String(t.getMinutes()).padStart(2,'0')}` : String(t);
        const parts = [ts];
        pts.forEach(p => {
          if (p.data.visible === false || p.data.visible === "legendonly") return;
          const name = (p.data.meta && p.data.meta.ma) ? `${p.data.name} (${p.data.meta.ma})` : p.data.name;
          let val = p.y;
          if (typeof val === "number") parts.push(`${name}: ${val.toFixed(3)}`);
          else parts.push(`${name}: ${val}`);
        });
        hb.textContent = parts.join("  |  ");
        hb.style.visibility = 'visible';
      });
      gd.on('plotly_unhover', () => {
        hb.textContent = '';
        hb.style.visibility = 'hidden';
      });
    }

    document.getElementById("monthSelect").onchange = (e) => {
      render(e.target.value);
    };

    async function init() {
      try {
        const resp = await fetch(`${aggBase}/months.json`);
        if (resp.ok) {
          const list = await resp.json();
          if (Array.isArray(list) && list.length) months = list;
        } else {
          console.warn("months.json load failed, using fallback");
        }
      } catch(e) {
        console.warn("months.json fetch error, using fallback", e);
      }
      await buildMonthOptions();
      render(months[0]);
    }

    init();
  </script>
</body>
</html>
